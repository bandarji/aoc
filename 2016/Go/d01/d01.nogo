package d01

import (
	"strconv"
	"strings"
)

type Position struct {
	Facing  int // N = 0, E = 1, S = 2, W = 3
	X, Y    int
	History map[string]bool
}

func (p Position) Distance() (d int) {
	return AbsDiff(0, p.X) + AbsDiff(0, p.Y)
}

func (p *Position) Move(instruction string) {
	dxm, dym, distance := 0, 0, 0
	if string(instruction[0]) == "R" {
		switch p.Facing {
		case 0:
			dxm += 1
			p.Facing = 1
		case 1:
			dym += 1
			p.Facing = 2
		case 2:
			dxm -= 1
			p.Facing = 3
		case 3:
			dym -= 1
			p.Facing = 0
		}
	} else {
		switch p.Facing {
		case 0:
			dxm -= 1
			p.Facing = 3
		case 1:
			dym -= 1
			p.Facing = 0
		case 2:
			dxm += 1
			p.Facing = 1
		case 3:
			dym += 1
			p.Facing = 2
		}
	}
	distance = atoi(instruction)
	p.X += dxm * distance
	p.Y += dym * distance
}

func atoi(s string) (i int) {
	is := ""
	for _, c := range s {
		if c >= 48 && c <= 57 {
			is += string(c)
		}
	}
	i, _ = strconv.Atoi(is)
	return
}

func ParseInstructions1(input string, p *Position) int {
	for _, instruction := range strings.Fields(input) {
		p.Move(instruction)
	}
	return p.Distance()
}

func ParseInstructions2(input string, p *Position) int {
	for _, instruction := range strings.Fields(input) {
		_ = instruction
	}
	return p.Distance()
}

func AbsDiff(i, j int) (d int) {
	d = i - j
	if d < 0 {
		d *= -1
	}
	return
}

func Day(input string, part int) int {
	p := &Position{0, 0, 0, map[string]bool{"0, 0": true}}
	if part == 1 {
		ParseInstructions1(input, p)
	} else {
		ParseInstructions2(input, p)
	}
	return p.Distance()
}
